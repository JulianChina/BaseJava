package EffectiveJava3rd.lSerialization;

//87 考虑使用自定义的序列化形式
public class L87 {
    //在没有考虑默认序列化形式是否合适之前，不要接受它。
    //如果对象的物理表示与其逻辑内容相同，则默认的序列化形式可能是合适的。
    //即使你认为默认的序列化形式是合适的，你通常也必须提供readObject方法来确保不变性和安全性。

    //当对象的物理表示与其逻辑数据内容有很大差异时，使用默认的序列化形式有四个缺点:
    // 它将导出的API永久地绑定到当前的内部实现。
    // 它会占用过多的空间。
    // 它会消耗过多的时间。
    // 它可能导致堆栈溢出。

    //writeObject做的第一件事是调用defaultWriteObject，readObject做的第一件事是调用defaultReadObject。
    //这些调用的存在使得在以后的版本中添加非瞬态实例字段成为可能，同时保留了向后和向前兼容性。
    //在决定使字段非transient之前，请确信它的值是对象逻辑状态的一部分。
    //无论你是否使用默认的序列化形式，必须对对象序列化强制执行任何同步操作，就像对读取对象的整个状态的任何其他方法强制执行的那样。
    //无论选择哪种序列化形式，都要在编写的每个可序列化类中声明显式的序列版本UID。
    //不要更改序列版本UID，除非你想破坏与现有序列化所有实例的兼容性。

    //如果你已经决定一个类应该是可序列化的，那么请仔细考虑一下序列化的形式应该是什么。
    // 只有在合理描述对象的逻辑状态时，才使用默认的序列化形式；否则，设计一个适合描述对象的自定义序列化形式。
    // 正如不能从未来版本中删除导出的方法一样，也不能从序列化形式中删除字段；必须永远保存它们，以确保序列化兼容性。
}
