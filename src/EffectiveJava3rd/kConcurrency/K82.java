package EffectiveJava3rd.kConcurrency;

//82 文档应包含线程安全属性
public class K82 {
    //方法声明中synchronized修饰符的存在是实现细节，而不是其API的一部分。它不能可靠地表明方法是线程安全的。
    //要启用安全的并发使用，类必须清楚地记录它支持的线程安全级别。
    // 不可变的 — 这个类的实例看起来是常量。不需要外部同步。示例包括String、Long和BigInteger
    // 无条件线程安全 — 该类的实例是可变的，但是该类具有足够的内部同步，因此无需任何外部同步即可并发地使用该类的实例。例如AtomicLong和ConcurrentHashMap。
    // 有条件的线程安全 — 与无条件线程安全类似，只是有些方法需要外部同步才能安全并发使用。示例包括Collections.synchronized包装器返回的集合，其迭代器需要外部同步。
    // 非线程安全 — 该类的实例是可变的。要并发地使用它们，客户端必须使用外部同步来包围每个方法调用(或调用序列)。这样的例子包括通用的集合实现，例如ArrayList和HashMap。
    // 线程对立 — 即使每个方法调用都被外部同步包围，该类对于并发使用也是不安全的。线程对立通常是由于在不同步的情况下修改静态数据而导致的。

    //当用户遍历Collections.synchronizedMap其集合视图时，必须手动同步返回的Map：
    /*
    Map<K, V> m = Collections.synchronizedMap(new HashMap<>());
    Set<K> s = m.keySet(); // Needn't be in synchronized block
    ...
    synchronized(m){ // Synchronizing on m, not s!
        for (K key : s)
            key.f();
    }
    */

    //类的线程安全的描述通常属于该类的文档注释，但是具有特殊线程安全属性的方法应该在它们自己的文档注释中描述这些属性。没有必要记录枚举类型的不变性。
    //Lock字段应该始终声明为final。
    //私有锁对象用法只能在无条件的线程安全类上使用。有条件的线程安全类不能使用这种用法，因为它们必须在文档中记录，在执行某些方法调用序列时要获取哪些锁。
    //私有锁对象用法特别适合为继承而设计的类。

    //每个类都应该措辞严谨的描述或使用线程安全注解清楚地记录其线程安全属性。
    //有条件的线程安全类必须记录哪些方法调用序列需要外部同步，以及在执行这些序列时需要获取哪些锁。
    //如果你编写一个无条件线程安全的类，请考虑使用一个私有锁对象来代替同步方法。这将保护你免受客户端和子类的同步干扰，并为你提供更大的灵活性，以便在后续的版本中采用复杂的并发控制方式。
}
