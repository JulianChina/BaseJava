package EffectiveJava3rd.aIntroduction;

public class A00 {
//第2章 创建和销毁对象
//    第1条：考虑使用静态工厂方法替代构造方法
//    第2条：当构造方法参数过多时使用builder模式
//    第3条：使用私有构造方法或枚类实现Singleton属性
//    第4条：使用私有构造器执行非实例化
//    第5条：依赖注入优于硬连接资源(hardwiring resources)
//    第6条：避免创建不必要的对象
//    第7条：消除过期的对象引用
//    第8条：避免使用Finalizer和Cleaner机制
//    第9条：使用try-with-resources语句替代try-finally语句

//第3章 对于所有对象都通用的方法
//    第10条：重写equals方法时遵守通用约定
//    第11条：重写equals方法时同时也要重写hashCode方法
//    第12条：始终重写toString方法
//    第13条：谨慎地重写clone方法
//    第14条：考虑实现Comparable接口

//第4章 类和接口
//    第15条：使类和成员的可访问性最小化
//    第16条：在公共类中使用访问方法而不是公共属性
//    第17条：最小化可变性
//    第18条：复合优于继承
//    第19条：要么设计继承并提供文档说明，要么禁用继承
//    第20条：接口优于抽象类
//    第21条：为后代设计接口
//    第22条：接口仅用来定义类型
//    第23条：类层次结构优于标签类
//    第24条：支持使用静态成员类而不是非静态类
//    第25条：将源文件限制为单个顶级类

//第5章 泛型
//    第26条：不要使用原始类型
//    第27条：消除非检查警告
//    第28条：列表优于数组
//    第29条：优先考虑泛型
//    第30条：优先使用泛型方法
//    第31条：使用限定通配符来增加API的灵活性
//    第32条：合理地结合泛型和可变参数
//    第33条：优先考虑类型安全的异构容器

//第6章 枚举和注解
//    第34条：使用枚举类型替代整型常量
//    第35条：使用实例属性替代序数
//    第36条：使用EnumSet替代位属性
//    第37条：使用EnumMap替代序数索引
//    第38条：使用接口模拟可扩展的枚举
//    第39条：注解优于命名模式
//    第40条：始终使用Override注解
//    第41条：使用标记接口定义类型

//第7章 Lambda和Stream
//    第42条：lambda表达式优于匿名类
//    第43条：方法引用优于lambda表达式
//    第44条：优先使用标准的函数式接口
//    第45条：明智审慎地使用Stream
//    第46条：优先考虑流中无副作用的函数
//    第47条：优先使用Collection而不是Stream来作为方法的返回类型
//    第48条：谨慎使用流并行

//第8章 方法
//    第49条：检查参数有效性
//    第50条：必要时进行防御性拷贝
//    第51条：仔细设计方法签名
//    第52条：明智审慎地使用重载
//    第53条：明智审慎地使用可变参数
//    第54条：返回空的数组或集合，不要返回null
//    第55条：明智审慎地返回Optional
//    第56条：为所有已公开的API元素编写文档注释

//第9章 通用编程
//    第57条：最小化局部变量的作用域
//    第58条：for-each循环优于传统for循环
//    第59条：了解并使用库
//    第60条：若需要精确答案就应避免使用float和double类型
//    第61条：基本数据类型优于包装类
//    第62条：当使用其他类型更合适时应避免使用字符串
//    第63条：当心字符串连接引起的性能问题
//    第64条：通过接口引用对象
//    第65条：接口优于反射
//    第66条：明智审慎地使用本地方法
//    第67条：明智审慎地进行优化
//    第68条：遵守被广泛认可的命名约定

//第10章 异常
//    第69条：只针对异常的情况下才使用异常
//    第70条：对可恢复的情况使用受检异常，对编程错误使用运行时异常
//    第71条：避免不必要的使用受检异常
//    第72条：优先使用标准的异常
//    第73条：抛出与抽象对应的异常
//    第74条：每个方法抛出的异常都需要创建文档
//    第75条：在细节消息中包含失败-捕获信息
//    第76条：保持失败原子性
//    第77条：不要忽略异常

//第11章 并发
//    第78条：同步访问共享的可变数据
//    第79条：避免过度同步
//    第80条：executor、task和stream优先于线程
//    第81条：并发工具优于wait和notify
//    第82条：文档应包含线程安全属性
//    第83条：明智审慎地使用延迟初始化
//    第84条：不要依赖线程调度器

//第12章 序列化
//    第85条：优先选择Java序列化的替代方案
//    第86条：非常谨慎地实现Serializable
//    第87条：考虑使用自定义的序列化形式
//    第88条：保护性地编写readObject方法
//    第89条：对于实例控制，枚举类型优于readResolve
//    第90条：考虑用序列化代理代替序列化实例
}
