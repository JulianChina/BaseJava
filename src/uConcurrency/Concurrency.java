package uConcurrency;

public class Concurrency {
    //并发"具有可论证的确定性，但实际上具有不可确定性"；
    //21.1 并发的多面性
        //用并发解决的问题大体上可以分为"速度"和"设计可管理性"两种；
        //更快地执行
            //并发通常是提高运行在单处理器上的程序的性能，这是由于阻塞的存在；
            //在单处理器的系统中的性能提高的常见示例是事件驱动的编程；
            //实现并发最直接的方式是在操作系统级别使用进程；进程是运行在它自己的地址空间内的自包容的程序；多任务操作系统可以通过周期性地将CPU从一个进程切换到另一个进程，来实现同时运行多个进程；
            //编写多线程程序最基本的困难在于在协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问；
        //改进代码设计
            //Java的线程机制是抢占式的，调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务；
    //21.2 基本的线程机制
        //一个线程就是在进程中的一个单一的顺序控制流；
        //多任务和多线程往往是使用多处理器系统的最合理方式；
        //定义任务
            //线程可以驱动任务，因此需要一种描述任务的方式，这可以由Runnable接口来提供；
            //LiftOff.java;
                //在run()中对静态方法Thread.yield()的调用是对线程调用器的一种建议；
            //MainThread.java;
            //当从Runnable导出一个类时，它必须具有run()方法，但是这个方法并无特别之处————它不会产生任何内在的线程能力；要实现线程行为，你必须显式地将一个任务附着到线程上；
        //Thread类
            //BasicThreads.java;
            //任何线程都可以启动另一个线程；
            //MoreBasicThreads.java;
        //使用Executor
            //Executor在客户端和任务执行之间提供了一个间接层，Executor允许你管理异步任务的执行，而无需显式地管理线程的生命周期；
            //CachedThreadPool将为每个任务都创建一个线程；
                //CachedThreadPool.java;
            //FixedThreadPool使用了有限的线程集来执行所提交的任务；
                //FixedThreadPool.java;
            //在任何线程池中，现有线程在可能的情况下，都会被自动复用；CachedThreadPool是合理的Executor的首选；
            //SingleThreadPool就像是线程数量为1的FixedThreadPool；如果向SingleThreadPool提交了多个任务，那么这些任务将按照提交顺序排队；
                //SingleThreadPool.java;
        //从任务中产生返回值
            //Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call()中返回的值，并且必须使用ExecutorService.submit()方法调用它；
            //CallableDemo.java;
                //可以在试图调用get()来获取结果之前，先调用具有超时的get()，或者调用isDone()来查看任务是否完成；
        //休眠
            //影响任务行为的一种简单方法是调用sleep()；
            //SleepingTask.java;
            //异常不能跨线程传播回main()，必须在本地处理所有在任务内部产生的异常；
        //优先级
            //线程的优先级将该线程的重要性传递给了调度器；优先级较低的线程仅仅是执行的频率较低；
            //SimplePriorities.java;
            //Thread.currentThread()以"线程名、优先级、所属线程组"来返回；
            //优先级在run()的开头部分设定，在构造器中设置它们不会有任何好处，因为Executor在此刻还没有开始执行任务；
            //唯一可移植的方法是当调整优先级的时候，只使用MAX_PRIORITY、NORM_PRIORITY和MIN_PRIORITY三种级别；
        //让步
            //当调用yield()时，你只是在建议具有相同优先级的其他线程可以运行；
        //后台线程
            //后台线程是指，在程序运行的时候在后台提供一种通用服务的线程；
            //当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程；
            //SimpleDaemons.java;
                //必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程；
            //通过编写定制的ThreadFactory可以定制由Executor创建的线程的属性（后台、优先级、名称）；
                //DaemonThreadFactory.java;
                //DaemonFromFactory.java;
            //每个静态的ExecutorService创建方法都被重载为接受一个ThreadFactory对象，而这个对象将被用来创建新的线程；
                //DaemonThreadPoolExecutor.java;
            //可以通过调用isDaemon()方法来确定线程是否是一个后台线程；如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程；
                //Daemons.java;
            //你应该意识到后台线程在不执行finally子句的情况下就会终止其run()方法；
                //DaemonsDontRunFinally.java;
            //非后台的Executor通常是一种更好的方式，因为Executor控制的所有任务可以同时被关闭；
        //编码的变体
            //直接从Thread继承；
                //SimpleThread.java;
            //自管理的Runnable；
                //SelfManaged.java;
                //实现接口使得你可以继承另一个不同的类；
                //在构造器中启动线程可能会变得很有问题，因为另一个任务可能会在构造器结束之前开始执行，这意味着该任务能够访问处于不稳定状态的对象；这是优选Executor而不是显式地创建Thread对象的另一个原因；
            //有时通过使用内部类来将线程代码隐藏在类中将会很有用；
                //ThreadVariations.java;
        //术语
        //加入一个线程
            //一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行；
            //如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复；也可以在调用join()时带上一个超时参数；
            //对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法；
            //Joining.java;
            //CyclicBarrier可能比最初的线程类库中的join()更加适合；
        //创建有响应的用户界面
            //使用线程的动机之一就是建立有响应的用户界面；
            //ResponsiveUI.java;
        //线程组
            //线程组持有一个线程集合；
        //捕获异常
            //由于线程的本质特性，使得你不能捕获从线程中逃逸的异常；
                //ExceptionThread.java;
                //NaiveExceptionHandling.java;
            //Thread.UncaughtExceptionHandler允许你在每个Thread对象上都附着一个异常处理器；
            //Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用；
                //CaptureUncaughtException.java;
            //如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方式是在Thread类中设置一个静态域，并将这个处理器设置为默认的未捕获异常处理器；
                //SettingDefaultHandler.java;
            //系统会先检查线程专有的未捕获异常处理器，再检查线程组是否有其专有的uncaughtException()方法，最后再调用defaultUncaughtExceptionHandler；
    //21.3 共享受限资源
        //可以把单线程程序当作在问题域求解的单一实体；
        //不正确地访问资源
            //IntGenerator.java;
            //EvenChecker.java;
            //通过使任务依赖于非任务对象，我们可以消除潜在的竞争条件；
            //EvenGenerator.java;
            //在Java中，递增不是原子性的操作；
        //解决共享资源竞争
            //你永远都不知道一个线程何时在运行；
            //序列化访问共享资源；互斥量；
            //共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入/输出端口，或者是打印机；
            //要控制对共享资源的访问，得先把它包装进一个对象，然后把所有要访问这个资源的方法标记为synchronized；
            //如果某个任务处于一个对标记为synchronized的方法的调用中，那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞；
            //【所有对象都自动含有单一的锁】；
            //在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突；
            //JVM负责跟踪对象被加锁的次数；
            //【针对每个类，也有一个锁（作为类的Class对象的一部分）】；
            //Brain同步规则：如果你正在写一个变量，它可能接下来将被另一个线程读取，或者如果你正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步；
            //每个访问临界共享资源的方法都必须被同步，否则它们就不会正确地工作；
            //同步控制EvenGenerator：
                //SynchronizedEvenGenerator.java;
            //使用显式的Lock对象：
                //MutexEvenGenerator.java;
                //Lock对象必须被显式地创建、锁定和释放；
                //通常只有在解决特殊问题时，才使用显式的Lock对象；
                //AttemptLocking.java;
                //ReentrantLock允许你尝试着获取但最终未获取锁；
        //原子性与易变性
            //原子操作是不能被线程调度机制中断的操作；
            //原子性可以应用于除long和double之外的所有基本类型之上的"简单操作"；
            //当定义long或double变量，如果使用volatile关键字，就会获得（简单的赋值与返回操作的）原子性；
            //volatile域会立即被写入到主存中，而读取操作就发生在主存中；
            //在非volatile域上的原子操作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值；
            //如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该经由同步来访问；
            //同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的；
            //使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域；总是应该首选synchronized关键字；
            //AtomicityTest.java;
            //SerialNumberGenerator.java;
            //1.基本上，如果一个域可能会被多个任务同时访问，或者这些任务中至少有一个是写入任务，那么你就应该将这个域设置成volatile的；
            //2.如果你将一个域定义为volatile，那么它就会告诉编译器不要执行任何移除读取和写入操作的优化，这些操作的目的是用线程中的局部变量维护对这个域的精确同步；
            //3.实际上，读取和写入都是直接针对内存的，而却没有被缓存；但是，volatile并不能对递增不是原子性操作这一事实产生影响；
            //SerialNumberChecker.java;
        //原子类
            //原子性变量类：AtomicInteger、AtomicLong、AtomicReference；
                //原子性条件更新操作：public final boolean compareAndSet(int expect, int update)
            //AtomicIntegerTest.java;
            //AtomicEvenGenerator.java;
        //临界区
            //有时，只是希望防止多个线程同时访问方法内部的部分代码，这种分离出来的代码段被称作临界区；通常采用synchronized来控制这段代码，因此也叫同步代码块；
            //通过使用同步控制块，而不是对整个方法进行同步控制，可以使多个任务访问对象的时间性能得到显著提高；
            //CriticalSelection.java;
            //宁愿使用同步控制块而不是对整个方法进行同步控制，使得其他线程能够更多地访问（在安全的情况下尽可能多）；
            //ExplicitCriticalSelection.java;
        //在其他对象上同步
            //synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象，synchronized(this)；
            //有时必须在另一个对象上同步，但是如果你要这么做，就必须确保所有相关的任务都是在同一个对象上同步的；
                //SyncObject.java;
        //线程本地存储
            //防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享；
            //线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储；
            //ThreadLocalVariableHolder.java;
            //ThreadLocal对象通常当做静态域存储；
            //在创建ThreadLocal时，只能通过get()和set()方法来访问该对象的内容；get()方法将返回与其线程相关联的对象的副本，而set()会将参数插入到为其线程存储的对象中，并返回存储中原有的对象；
            //ThreadLocal保证不会出现竞争条件；
    //21.4 终结任务
        //装饰性花园
            //OrnamentalGarden.java;
        //在阻塞时终结
            //线程状态：新建、就绪、阻塞、死亡；
            //进入阻塞状态：sleep(milliseconds)、wait()、等待I/O、等待锁；
        //中断
            //Interrupting.java;
                //I/O和在synchronized块上的等待是不可中断的，能够中断对sleep()的调用（或者任何要求抛出InterruptedException的调用）；
            //CloseResource.java;
            //被阻塞的nio通道会自动地响应中断；
                //NIOInterruption.java;
            //被互斥所阻塞
                //同一个互斥可以被同一个任务多次获得；
                //MultiLock.java;
            //在ReentrantLock上阻塞的任务具备可以被中断的能力；
                //Interrupting2.java;
        //检查中断
            //注意，当你在线程上调用interrupt()时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时；
            //通过中断状态设置及检查来控制退出；
                //InterruptingIdiom.java;
    //21.5 线程之间的协作
        //任务间的握手问题：通过Object的方法wait()和notify()来安全地实现；
        //wait()与notifyAll()
            //调用sleep()的时候锁并没有被释放，调用yield()也属于这种情况；
            //wait()将释放锁；
            //只能在同步控制方法或同步控制块里调用wait()、notify()和notifyAll()；因为不用操作锁，sleep()可以在非同步控制方法里调用；
            //WaxOMatic.java;
            //当你调用某个ExecutorService的shutdownNow()时，它会调用所有由它控制的线程的interrupt()；
            //错失的信号：synchronized的时机很重要，不然会错失信号；
        //notify()与notifyAll()
            //使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒；如果希望使用notify()，就必须保证被唤醒的是恰当的任务；
            //当notifyAll()因某个特定锁而被调用时，只有等待这个锁的任务才会被唤醒；
            //NotifyVsNotifyAll.java;
        //生产者与消费者
            //Restaurant.java;
            //在典型的生产者-消费者实现中，应使用先进先出队列来存储被生产和消费的对象；
            //使用显式的Lock和Condition对象
                //使用互斥并允许任务挂起的基本类是Condition；await()/signal()/signalAll()；
                //WaxOMatic2.java;
                //每一个对lock()的调用都必须紧跟一个try-finally子句，用来保证在所有情况下都可以释放锁；
        //生产者-消费者与队列
            //使用同步队列来解决任务协作问题，同步队列在任何时刻都只允许一个任务插入或移除元素；java.util.concurrent.BlockingQueue；
            //TestBlockingQueues.java;
            //吐司BlockingQueue
                //ToastOMatic.java;
        //任务间使用管道进行输入/输出
            //PipedWriter类允许任务向管道写；PipedReader类允许不同任务从同一个管道中读取；
            //PipedIO.java;
            //PipedReader的建立必须在构造器中与一个PipedWriter相关联；
            //PipedReader是可中断的；如果将in.read()调用改为System.in.read()，那么interrupt()将不能打断read()调用；
    //21.6 死锁
        //一个对象可以有synchronized方法或其他形式的加锁机制来防止别的任务在互斥还没有释放的时候就访问这个对象；
        //Chopstick.java; Philosopher.java; DeadlockingDiningPhilosophers.java;
        //当以下4个条件同时满足时，就会发生死锁：1）互斥条件；2）持有等待；3）资源不可抢占；4）循环等待；
        //防止死锁最容易的方法是破坏"循环等待"条件；
            //FixedDiningPhilosopher.java;
    //21.7 新类库中的构件
        //CountDownLatch
            //被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成；
            //1.可以向CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()的方法都将阻塞，直至这个计数值到达0；
            //2.其他任务在结束其工作时，可以在该对象上调用countDown()来减少这个计数值；
            //3.CountDownLatch被设计为只触发一次，计数值不能被重置；如果你需要能重置计数值的版本，可以使用CyclicBarrier；
            //CountDownLatchDemo.java;
            //类库的线程安全
        //CyclicBarrier
            //创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成（看起来有些像join()）；
            //1.所有的并行任务都将在栅栏处列队，因此可以一致地向前移动，非常像CountDownLatch；
            //2.CountDownLatch是只触发一次的事件，而CyclicBarrier可以多次重用；
            //HorseRace.java;
            //可以向CyclicBarrier提供一个"栅栏动作"，它是一个Runnable，当所有的绑定CyclicBarrier的线程都调用await而进入栅栏之后，栅栏动作就开始执行；
        //DelayQueue
            //这是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走；
            //队列是有序的，对头对象的延迟到期的时间最长（注意此处的理解）；如果没有任何延迟到期，那么就不会有任何头元素，并且poll()将返回null；
            //DelayQueueDemo.java;
                //为了排序，Delayed接口还继承了Comparable接口，因此必须实现compareTo()；
        //PriorityBlockingQueue
            //基础的优先级队列，具有可阻塞的读取操作；
            //PriorityBlockingQueueDemo.java;
        //使用ScheduleExecutor的温室控制器
            //GreenhouseScheduler.java;
        //Semaphore
            //正常的锁（来自concurrent.locks或内建的synchronized锁）在任何时刻都只允许一个任务访问一项资源；
            //计数信号量允许n个任务同时访问这个资源，可以将信号量看作是在向外分发使用资源的"许可证"，尽管实际上没有使用任何许可证对象；
            //对象池；
            //Pool.java; Fat.java; SemaphoreDemo.java;
            //一旦池中所有对象都被签出，Semaphore将不再允许执行任何签出操作；冗余的迁入将被Pool忽略；
        //Exchanger
            //Exchanger是在两个任务之间交换对象的栅栏；当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象；
            //ExchangeDemo.java;
    //21.8 仿真
        //银行出纳员仿真

        //饭店仿真

        //分发工作

    //21.9 性能调优
        //比较各类互斥技术
            //SimpleMicroBenchmark.java;
            //SynchronizationComparisons.java;
                //在MAC上运行之后的性能比较结果：synchronized < Lock < Atomic；
        //免锁容器
            //免锁容器背后的通用策略：
                //1.对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可；
                //2.修改是在容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）上执行的，并且这个副本在修改过程中是不可视的；
                //3.只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到这个修改了；
            //CopyOnWriteArrayList：
                //1.写入将导致创建整个底层数据的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行；
                //2.当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新的修改；
                //3.当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException；
            //CopyOnWriteArraySet：使用CopyOnWriteArrayList来实现其免锁行为；
            //ConcurrentHashMap和ConcurrentLinkedQueue使用了类似的技术，允许并发地读取和写入，但是容器中只有部分内容而不是整个容器可以被复制和修改；
            //乐观锁
                //只要你主要是从免锁容器中读取，那么它就会比其synchronized对应物快许多；
                //Tester.java; ListComparisons.java;
                //CopyOnWriteArrayList相比于synchronizedList，在没有写入者时，速度会快许多，并且在有5个写入者时，速度仍旧明显地快；
            //比较各种Map实现
                //MapComparisons.java;
                //ConcurrentHashMap相比于synchronizedMap，速度会快许多，明显地最小化写入所造成的影响；
        //乐观加锁
            //compareAndSet()：你将旧值和新值一起提交给这个方法，如果旧值与它在Atomic对象中发现的值不一致，那么这个操作就失败；
            //FastSimulation.java;
        //ReadWriteLock
            //ReadWriteLock对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化；
            //ReadWriteLock使得你可以同时有多个读取者，只要它们都不试图写入即可；如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止；
            //ReaderWriterList.java;
            //ReentrantReadWriteLock是一个相当复杂的工具，只有当你在搜索可以提高性能的方法时，才应该想到它；只有在必需时再引入ReadWriteLock；
    //21.10 活动对象
        //Java的多线程模型来自于过程型编程世界，并且几乎没做什么改变；
        //有一种可替换的方式被称为活动对象或行动者；
        //"活动的"：每个对象都维护着它自己的工作器线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中一个；
        //有了活动对象，我们就可以串行化消息而不是方法，意味着不再需要防备一个任务在其循环的中间被中断这种问题了；
        //Future；
        //ActiveObjectDemo.java;
        //有了活动对象，你不必操心应该如何同步方法；同步仍旧会发生，但是它通过将方法调用排队，使得任何时刻都只能发生一个调用，从而将同步控制在消息级别上发生；
    //21.11 总结
        //Java并发编程：
            //1.可以运行多个独立的任务；
            //2.必须考虑当这些任务关闭时，可能出现的所有问题；
            //3.任务可能会在共享资源上彼此干涉；互斥（锁）是用来防止这种冲突的基本工具；
            //4.如果任务设计得不够仔细，就有可能发生死锁；
        //一个给定进程内的所有线程共享相同的内存空间，轻量级的上下文切换只是改变了程序的执行序列和局部变量；进程切换（重量级的上下文切换）必须改变所有内存空间；
        //多线程的主要缺陷：
            //1.等待共享资源的时候性能降低；
            //2.需要处理线程的额外CPU花费；
            //3.糟糕的程序设计导致不必要的复杂度；
            //4.有可能产生一些病态行为，如饿死、竞争、死锁、活锁（多个运行各自任务的线程使得整体无法完成）；
            //5.不同平台导致的不一致性；
        //不管在使用某种特定的语言或类库时，线程机制看起来是多么地简单，你都应该视其为魔法；
        //Erlang这样的语言，是专门用于线程机制的几种函数型语言之一；
}
